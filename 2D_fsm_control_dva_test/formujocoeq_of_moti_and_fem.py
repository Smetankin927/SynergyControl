# -*- coding: utf-8 -*-
"""ForMujocoEq_of_moti_and_fem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qSb3e57LaSQb5F5mswlGKYnLy-gY5dSO
"""

import sympy as sym
from sympy import Matrix, init_printing, symbols, solve, eye, Rational, sin, cos, simplify, Eq, evaluate
from sympy import diag, collect, expand, sqrt, latex
import numpy as np
# import matplotlib.pyplot as plt
init_printing()



"""## Вывод уравнений движения.
Для справки смотреть в "Введение в механику человека" Коренев Г. В. (https://books.mipt.ru/book/301072) главы 10, 11

### first part
"""

# Define rhs of the system 1
x1, x2, y1, y2 = symbols("x_1 x_2 y_1 y_2",real=True)
fi1, fi2 = symbols("\phi_1 \phi_2", real=True)
m1, m2, I1, I2 = symbols("m_1 m_2 I_1 I_2",real=True)
F11, F12, F21, F22 = symbols("F_11 F_12 F_21 F_22", real=True)
M1, M2 = symbols("M_1, M_2", real=True)
L1, L2 = symbols("L_1, L_2", real=True)
R11, R12, R21, R22 = symbols("R_11 R_12 R_21 R_22", real=True)

dx1, dx2, dy1, dy2 = symbols("\dot{x_1} \dot{x_2} \dot{y_1} \dot{y_2}",real=True)
dfi1, dfi2 = symbols("\dot{\phi_1} \dot{\phi_2}", real=True)

ddx1, ddx2, ddy1, ddy2 = symbols("\ddot{x_1} \ddot{x_2} \ddot{y_1} \ddot{y_2}",real=True)
ddfi1, ddfi2 = symbols("\ddot{\phi_1} \ddot{\phi_2}", real=True)

b = diag(m1, m1, m2, m2, I1, I2)
ddksi = Matrix([ddx1, ddy1, ddx2, ddy2, ddfi1, ddfi2 ])
X = Matrix([F11, F12, F21, F22, M1, M2])
Z = Matrix([R11, R12, R21, R22, L1, L2])

b

b @ ddksi, X + Z



"""### second part"""

from sympy.physics.mechanics import dynamicsymbols, init_vprinting
init_vprinting()

t = symbols("t")
fi1, fi2 = dynamicsymbols('\phi_1 phi_2')

# l == 1/2 of lenght
l1, l2 = symbols("l_1 l_2", real=True)

x1 = l1*sin(fi1)
y1 = l1*cos(fi1)
x2 = 2*l1*sin(fi1) + l2*sin(fi2)
y2 = 2*l1*cos(fi1) + l2*cos(fi2)

dy1 = y1.diff(t)
dx1 = x1.diff(t)
dy2 = y2.diff(t)
dx2 = x2.diff(t)
dy1, dx1, dy2, dx2

ksi = Matrix([x1,y1,x2,y2, fi1, fi2])
ksi

ksi.diff(t)

dksi = Matrix([dx1,dy1,dx2,dy2, fi1.diff(t), fi2.diff(t)])
dksi

ddksi = dksi.diff(t)
ddksi

dksi_f = Matrix.hstack(ksi.diff(fi1),ksi.diff(fi2)) # матрица как у Коренева (11.5)
dksi_f

"""### third part"""

(simplify(dksi_f.T) @ X) # свертка по индексу левой части

a = (simplify(dksi_f.T) @ X)[1] # просто для красоты
a

c =(simplify(dksi_f.T) @ X)[0].collect(l1*sin(fi1)).collect(l1*cos(fi1)) # просто для красоты
c

Matrix([c,a]) # просто для красоты. свертка по индексу левой части

simplify((dksi_f.T @ (b @ ddksi))) # свертка по индексу правой части

# если приравняем друг другу две верхние матрицы, то получим конечное выражение без реакций связи в терминах углов вертикали

"""## Разбитие на подматрицы"""

C = Matrix([[I1 + l1**2 * m1 + 4*l1**2 * m2,  2*l1*l2*m2*cos(fi1-fi2)],
[2*l1*l2*m2*cos(fi1-fi2),  I2 + l2**2 * m2]])

C # * ddfi -- матрица, стоящая при вторых производных

K = Matrix([[0, 2*l1*l2*m2*sin(fi1-fi2)],
            [-2*l1*l2*m2*sin(fi1-fi2), 0]])

K # * dfi**2 -- матрица, стоящая при квадратах угловых скоростей. Дальше нам не понадобится

D = Matrix([c,a]) - Matrix([M1, M2])

D # Forces. Not control torques. -- матрица, стоящая при углах

C, D

# C ddbeta + s= D + N@M В ТЕРМИНАХ УГЛОВ ВЕРТИКАЛИ

"""## Линеаризация.
Возле положения (0,0) в терминах углов от вертикали
"""

linC = C.subs({cos(fi1-fi2) : 1})
linC

# linK = K.subs({sin(fi1-fi2) : fi1-fi2}) #матрица при скоростях, которую мы не берем в рассчет
# linK # problem dfi**2 но, если dfi == 0, то норм

D.subs({sin(fi1):fi1, sin(fi2):fi2, cos(fi1):1, cos(fi2):1})

linD1 = D.subs({sin(fi1):fi1, sin(fi2):fi2, cos(fi1):1, cos(fi2):1})
linD1 = linD1 - Matrix([l1*(F11+2*F21), l2*F21])

linD1

linDm = Matrix([[linD1[0]/fi1, 0],
                [0,linD1[1]/fi2]])
linDm  # F = - mg  ЗНАК!!! положительный

linC, linDm  # linC ddX - linDm X = N@M   В терминах углов вертикали

"""## Переход системы к суставным углам"""

N = Matrix([[1, -1],
            [0,  1]])
N

U = (N.inv()).T
U

M = Matrix([M1, M2])

Cs = U.T @ linC @ U  # скорее ввсего на R.T домножаем просто чтоб расщепить моменты
Ds = U.T @ linDm @ U
Ms = U.T @ N @ M
Cs, Ds, Ms  # Cs ddX - Ds X = Ms  X -- суставные углы

"""## Пишем в синергиях

В дальнейшем работать в символьном виде становится неудобным, поэтому определим  числа
"""

# m1ch = 3.0  # 3 килограмма и 0.4 метра
# m2ch = 3.0  # 3 килограмма и 0.4 метра полная длина одного сегмента
# l = 0.4/2 #  0.4 метра полная длина одного сегмента в муджоко надо полдлины и радиус
# #  I = 1/3 mL**2 = 4/3 ml**2

# I1ch = 1/12 * m1ch * (2*l)**2 #1.066 + m1ch*(0.272**2)
# I2ch = 1/12 * m2ch * (2*l)**2 #1.475 + m2ch*(0.337**2)

# gch = 9.8
m1ch = 3.0  # 3 килограмма и 0.4 метра
m2ch = 3.0  # 3 килограмма и 0.4 метра полная длина одного сегмента
l = 0.4/2 #  0.4 метра полная длина одного сегмента в муджоко надо полдлины и радиус
#  I = 1/3 mL**2 = 4/3 ml**2

I1ch = 1/12 * m1ch * (2*l)**2 #1.066 + m1ch*(0.272**2)
I2ch = 1/12 * m2ch * (2*l)**2 #1.475 + m2ch*(0.337**2)

gch = 9.8

subsch = {m1: m1ch, m2: m2ch, l1:l, l2:l, I1: I1ch, I2: I2ch, F12: (-m1ch*gch), F22: (-m2ch*gch)}

Cch = Cs.subs(subsch)
Cch

Dch = Ds.subs(subsch)
Dch

"""### синергии -- диагонализация системы"""

tmp2 = (Dch.inv()@Cch)
tmp2.eigenvects()

wa = tmp2.eigenvects()[0][2][0]

wh = tmp2.eigenvects()[1][2][0]

W = Matrix.hstack(wa,wh)
W

from functools import partial
round3 = partial(round, ndigits=4)

C_sing = W.inv()@Dch.inv()@Cch@W
C_sing.applyfunc(round3)

D_sing = W.inv()@Dch.inv()@Dch@W
D_sing.applyfunc(round3)

# T_sing = W.inv()@Dch.inv()@Ms
# T_sing

C_sing.applyfunc(round3), D_sing.applyfunc(round3)#, T_sing # Cddksi - Dksi = etas в термиинах синергий

"""## Доказательство справедливости линейного приближения

### Пишем профиль скоростей в терминах синергий (динамических переменных)
"""

b_up = - m2*l1/(m1+m2)
b_dw = - (m1*l1 + m2*l2 + 2*m2*l1)/(m1+m2)

b_upch = b_up.subs(subsch)
b_dwch = b_dw.subs(subsch)

b_m = Matrix([b_upch, b_dwch])
b_m

times = np.linspace(0,4,4000) # 4 секунды

vel_prof1 = 0.1/(1+(times-2)**2) * float(1/b_dwch)
vel_prof2 = 0.1/(1+(times-2)**2) * float(1/b_upch)

1/(1+(-2)**2) * float(1/b_dwch)

import matplotlib.pyplot as plt
# plt.plot(times,vel_prof1)
# plt.plot(times,vel_prof2)
# plt.show()



"""###  дифференцируем, получаем ускорения в терминах синергий (динамических переменных)"""

acc_prof1=np.gradient(vel_prof1, times)
acc_prof2=np.gradient(vel_prof2, times)

# plt.plot(times,acc_prof1)
# plt.plot(times,acc_prof2)
# plt.show()

"""## интегрируем в терминах синергий (динамических переменных)"""

def cumtrapz(y,x):
    res = np.array([np.trapz(y[:i], x[:i]) for i in range(len(x))])
    return res

sinerg_prof1 = cumtrapz(vel_prof1, times)
sinerg_prof2 = cumtrapz(vel_prof2, times)

# plt.plot(times,sinerg_prof1)
# plt.plot(times,sinerg_prof2)
# plt.show()

"""### вычисляем торки в терминах синергий"""

acc_prof1 = [float(item) for item in acc_prof1]
acc_prof2 = [float(item) for item in acc_prof2]
sinerg_prof1 = [float(item) for item in sinerg_prof1]
sinerg_prof2 = [float(item) for item in sinerg_prof2]

T_etas = C_sing.applyfunc(round3)@ Matrix([acc_prof1, acc_prof2]) + D_sing.applyfunc(round3)@Matrix([sinerg_prof1,sinerg_prof2])
T_etas.shape



"""### Переход из динамических переменных в суставные углы, прямое преобразование"""

T_etas_s1 = [T_etas[0,i] for i in range(len(T_etas)//2)] # управляющие моменты
T_etas_s2 = [T_etas[1,i] for i in range(len(T_etas)//2)]

# plt.plot(times,T_etas_s1)
# plt.plot(times,T_etas_s2)
# plt.show()

# в суставных углах
zer = [0 for i in range(len(T_etas_s1))]

T_joints_s1 = Dch@W@ Matrix([T_etas_s1, zer]) # для одной синергии, т.е вектора [\eta_1, 0]
T_joints_s2 = Dch@W@ Matrix([zer, T_etas_s2]) # для одной синергии, т.е вектора [0, \eta_2]
T_joints_s3 = Dch@W@ Matrix([T_etas_s1, T_etas_s2]) # для двух синергий, т.е вектора [\eta_1, \eta_2]

# (Dch@W).eigenvals()

"""#### выберем для определенности вторую синергию, то есть вектор $$ T = DW \left[0,\eta_2\right]^{T}$$"""

t_s1_plt1 = [T_joints_s2[0,i] for i in range(len(T_joints_s1)//2) ]
t_s1_plt2 = [T_joints_s2[1,i] for i in range(len(T_joints_s1)//2) ]
# plt.plot(times,t_s1_plt1)
# plt.plot(times,t_s1_plt2)
# plt.show()

"""#### смотрим какие суставные углы соответствуют нашим найденным выше динамическим переменным, через прямое преобразование"""

zer = [0 for i in range(len(sinerg_prof1))]
JA1 = W@Matrix([sinerg_prof1, zer])#одна синергия
JA2 = W@Matrix([zer, sinerg_prof2])#другая синергия

JA3 = W@Matrix([sinerg_prof1, sinerg_prof2])#сумма синергий



# plt.plot(times,[JA1[0,i] for i in range(len(JA1)//2)]) #одна синергия
# plt.plot(times,[JA1[1,i] for i in range(len(JA1)//2)])
# plt.show()

# plt.plot(times,[JA2[0,i] for i in range(len(JA2)//2)]) # другая синергия, та, которую мы рассматриваем, соответствующая вектору [0, \eta_2]
# plt.plot(times,[JA2[1,i] for i in range(len(JA2)//2)])
# plt.show()

# plt.plot(times,[JA3[0,i] for i in range(len(JA3)//2)]) # сумма синергий
# plt.plot(times,[JA3[1,i] for i in range(len(JA3)//2)])
# plt.show()

#  Cch ddx - Dch x  = T_joints в терминах суставных углов

"""### Теперь мы должны взять полученные ранее управляющие моменты и, используя их в линейной системе, получить суставные углы и сравнить их с углами, полученными при помощи явного преобразования из динамических переменных в суставные углы.

Пишем прогонку
"""
