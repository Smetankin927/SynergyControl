# -*- coding: utf-8 -*-
"""TryAfterOneCopyofFindParamsSim.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VSSL8X94nEAV8MMPS8-kU3uLC6YVmMYu
"""

import sympy as sym
from sympy import Matrix, init_printing, symbols, solve, eye, Rational, sin, cos, simplify, Eq, evaluate
from sympy import diag, collect, expand, latex
import numpy as np
# import matplotlib.pyplot as plt
init_printing()

# Define rhs of the system 1
x1, x2, y1, y2 = symbols("x_1 x_2 y_1 y_2",real=True)
fi1, fi2 = symbols("\phi_1 \phi_2", real=True)
m1, m2, I1, I2 = symbols("m_1 m_2 I_1 I_2",real=True)
F11, F12, F21, F22 = symbols("F_11 F_12 F_21 F_22", real=True)
M1, M2 = symbols("M_1, M_2", real=True)
L1, L2 = symbols("L_1, L_2", real=True)
R11, R12, R21, R22 = symbols("R_11 R_12 R_21 R_22", real=True)

dx1, dx2, dy1, dy2 = symbols("\dot{x_1} \dot{x_2} \dot{y_1} \dot{y_2}",real=True)
dfi1, dfi2 = symbols("\dot{\phi_1} \dot{\phi_2}", real=True)

ddx1, ddx2, ddy1, ddy2 = symbols("\ddot{x_1} \ddot{x_2} \ddot{y_1} \ddot{y_2}",real=True)
ddfi1, ddfi2 = symbols("\ddot{\phi_1} \ddot{\phi_2}", real=True)

b = diag(m1, m1, m2, m2, I1, I2)
ddksi = Matrix([ddx1, ddy1, ddx2, ddy2, ddfi1, ddfi2 ])
X = Matrix([F11, F12, F21, F22, M1, M2])
Z = Matrix([R11, R12, R21, R22, L1, L2])

from sympy.physics.mechanics import dynamicsymbols, init_vprinting
init_vprinting()

# # then you need to define x as a functions of time
t = symbols("t")
fi1, fi2 = dynamicsymbols('\phi_1 phi_2')

# l == 1/2 of lenght
l1, l2 = symbols("l_1 l_2", real=True)

x1 = l1*sin(fi1)
y1 = l1*cos(fi1)
x2 = 2*l1*sin(fi1) + l2*sin(fi2)
y2 = 2*l1*cos(fi1) + l2*cos(fi2)

dy1 = y1.diff(t)
dx1 = x1.diff(t)
dy2 = y2.diff(t)
dx2 = x2.diff(t)

ksi = Matrix([x1,y1,x2,y2, fi1, fi2])

dksi = Matrix([dx1,dy1,dx2,dy2, fi1.diff(t), fi2.diff(t)])

ddksi = dksi.diff(t)

dksi_f = Matrix.hstack(ksi.diff(fi1),ksi.diff(fi2))

# (simplify(X.T@dksi_f))

a = (simplify(dksi_f.T) @ X)[1]

c =(simplify(dksi_f.T) @ X)[0].collect(l1*sin(fi1)).collect(l1*cos(fi1))

C = Matrix([[I1 + l1**2 * m1 + 4*l1**2 * m2,  2*l1*l2*m2*cos(fi1-fi2)],
[2*l1*l2*m2*cos(fi1-fi2),  I2 + l2**2 * m2]])

G = Matrix([c,a]) - Matrix([M1, M2])

M = Matrix([M1, M2])

linC = C.subs({cos(fi1-fi2) : 1})

linG1 = G.subs({sin(fi1):fi1, sin(fi2):fi2, cos(fi1):1, cos(fi2):1})
linG1 = linG1 - Matrix([l1*(F11+2*F21), l2*F21])
linG2 = Matrix([l1*(F11+2*F21), l2*F21])

N = Matrix([[1, -1],
             [0,  1]])

linDm = Matrix([[linG1[0]/fi1, 0],
                [0,linG1[1]/fi2]])

R = (N.inv()).T

Cs = R.T @ linC @ R  # скорее ввсего на R.T домножаем просто чтоб расщепить моменты
Ds = R.T @ linDm @ R
Ms = R.T @ N @ M

C11, C12, C22 = symbols("C_11 C_12 C_22", real = True)
D11, D22 = symbols("D_11 D_22", real = True)

Cn  = Matrix([[C11, C12],
              [C12, C22]])

Dn = Matrix([[D11, D22],
             [D22, D22]])

tmp = (Dn.inv()@Cn)

# -lambd * ddksi + ksi = eta

m1ch = 3.0  # 3 килограмма и 0.4 метра
m2ch = 3.0  # 3 килограмма и 0.4 метра полная длина одного сегмента
l = 0.4/2 #  0.4 метра полная длина одного сегмента в муджоко надо полдлины и радиус
#  I = 1/3 mL**2 = 4/3 ml**2

I1ch = 1/12 * m1ch * (2*l)**2 #1.066 + m1ch*(0.272**2)
I2ch = 1/12 * m2ch * (2*l)**2 #1.475 + m2ch*(0.337**2)

gch = 9.8

subsch = {m1: m1ch, m2: m2ch, l1:l, l2:l, I1: I1ch, I2: I2ch, F12: (-m1ch*gch), F22: (-m2ch*gch)}

Cch = Cs.subs(subsch)

Dch = Ds.subs(subsch)

tmp2 = (Dch.inv()@Cch)

tmp2.eigenvects()

wa = tmp2.eigenvects()[0][2][0]

wh = tmp2.eigenvects()[1][2][0]

W = Matrix.hstack(wa,wh)

Uinv = (-Dch@W).inv()

# Z = Uinv@Cch@W

# from functools import partial

# round3 = partial(round, ndigits=4)
# Z.applyfunc(round3)

# w = symbols("\omega", real=True)
# t = symbols("t", real=True)
# V, S = symbols("V S", real=True)
# a = symbols("a", real=True)
# ll = symbols("\lambda", real=True)

# L = Matrix([[cos(w*t), a*cos(w*t)+w*sin(w*t)],
#             [sin(w*t), a*sin(w*t)-w*cos(w*t)]])

# R = Matrix([(1+ll*(w**2 - a**2))*sym.exp(a*t),
#             2*ll*w*a*sym.exp(a*t)])

# SV = simplify(L.inv()@R)


# import numpy as np

# SVsubs = {ll:0.0039, a:-3.5, t:0.06}

# lin =  np.linspace(0.2,30,10)

# ArSV = SV.subs(SVsubs)

# ArS = [ArSV[0].subs({w:str(i)}) for i in lin]

# ArV = [ArSV[1].subs({w:str(i)}) for i in lin]



# Vv = np.linspace(0.02,0.6)

# Ss = -(ll*a**2-1)*sym.exp(a*t)
# Ss = Ss.subs(SVsubs) -a.subs(SVsubs)*Vv


# import numpy as np

# SVsubs = {ll:0.05272, a:-3, t:0.12}

# lin =  np.linspace(1,30,10)

# ArSV = SV.subs(SVsubs)

# ArS = [ArSV[0].subs({w:str(i)}) for i in lin]

# ArV = [ArSV[1].subs({w:str(i)}) for i in lin]

# import matplotlib.pyplot as plt

# plt.plot(ArV,ArS)

# Vv = np.linspace(0.15,0.6)

# Ss = -(ll*a**2-1)*sym.exp(a*t)
# Ss = Ss.subs(SVsubs) -a.subs(SVsubs)*Vv


# Seig = Matrix([[0.21, 0],
#                   [0, 0.335]]) # диагональная

# Veig = Matrix([[0.3,     0],
#                  [0, 0.195]])  # диагональная

"""### Генерация траектории"""

U = Uinv.inv()

# Snorm = U@Seig@(W.inv())

# Vnorm = U@Veig@(W.inv())

# f = 0.5 #Hz
# A = 0.01

# fi_des1 = Dch[0,0]/Dch[1,1] * A*sin(2*np.pi*f*t)
# fi_des2 = A*sin(2*np.pi*f*t)

# fi1_plt = []
# fi2_plt = []
# for i in np.linspace(-5,5,100):
#   stt = {t:i}
#   fi1_plt.append(fi_des1.subs(stt))
#   fi2_plt.append(fi_des2.subs(stt))

