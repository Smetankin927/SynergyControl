# -*- coding: utf-8 -*-
"""SimONEFindParamsSim.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X-OHmIkpgBZf_JEdvN29rYiaPQ3cmp1m
"""

import sympy as sym
from sympy import Matrix, init_printing, symbols, solve, eye, Rational, sin, cos, simplify, Eq, evaluate
from sympy import diag, collect, expand, latex
import numpy as np
# import matplotlib.pyplot as plt
init_printing()

# Define rhs of the system 1
x1, y1= symbols("x_1 y_1 ",real=True)
fi1 = symbols("\phi_1 ", real=True)
m1, I1, = symbols("m_1 I_1 ",real=True)
F11 = 0
F12 = symbols("F_12", real=True)
M1 = symbols("M_1", real=True)
L1 = symbols("L_1", real=True)
R11, R12 = symbols("R_11 R_12", real=True)

dx1,dy1 = symbols("\dot{x_1} \dot{y_1}",real=True)
dfi1 = symbols("\dot{\phi_1}", real=True)

ddx1, ddy1 = symbols("\ddot{x_1}  \ddot{y_1}",real=True)
ddfi1 = symbols("\ddot{\phi_1}", real=True)

b = diag(m1, m1, I1)
ddksi = Matrix([ddx1, ddy1, ddfi1])
X = Matrix([F11, F12, M1])
Z = Matrix([R11, R12, L1])

from sympy.physics.mechanics import dynamicsymbols, init_vprinting
init_vprinting()

# # then you need to define x as a functions of time
t = symbols("t")
# x = Function("x")(t)

# # Now you can visualize derivatives with dots
# Derivative(x, t)

fi1 = dynamicsymbols('\phi_1')

# l == 1/2 of lenght
l1 = symbols("l_1", real=True)

# y1 = l1*sin(fi1)
# x1 = l1*cos(fi1)
# y2 = 2*l1*sin(fi1) + l2*sin(fi2)
# x2 = 2*l1*cos(fi1) + l2*cos(fi2)

x1 = l1*sin(fi1)
y1 = l1*cos(fi1)
# x2 = 2*l1*sin(fi1) + l2*sin(fi2)
# y2 = 2*l1*cos(fi1) + l2*cos(fi2)

dy1 = y1.diff(t)
dx1 = x1.diff(t)
# dy2 = y2.diff(t)
# dx2 = x2.diff(t)

ksi = Matrix([x1,y1, fi1])

dksi = Matrix([dx1,dy1,fi1.diff(t)])

ddksi = dksi.diff(t)

dksi_f = Matrix.hstack(ksi.diff(fi1))

a = (simplify(dksi_f.T) @ X)

c =(simplify(dksi_f.T) @ X)[0].collect(l1*sin(fi1)).collect(l1*cos(fi1))
# c = l1*cos(fi1)*(F11 + 2*F22)-l1*sin(fi1)*(F11 + 2*F21) + M1

C = Matrix([I1 + l1**2 * m1 ])

G = Matrix([c]) - Matrix([M1])

M = Matrix([M1])

linC = C.subs({cos(fi1) : 1})

linG1 = G.subs({sin(fi1):fi1, cos(fi1):1})

N = Matrix([1])

linDm = Matrix([linG1[0]/fi1])

R = (N.inv())

"""## Переход системы к суставным углам"""

Cs = R.T @ linC @ R  # скорее ввсего на R.T домножаем просто чтоб расщепить моменты
Ds = R.T @ linDm @ R
Ms = R.T @ N @ M

m1ch = 3.0  # 3 килограмма и 0.4 метра
m2ch = 3.0  # 3 килограмма и 0.4 метра полная длина одного сегмента
l = 0.4/2 #  0.4 метра полная длина одного сегмента в муджоко надо полдлины и радиус
#  I = 1/3 mL**2 = 4/3 ml**2

I1ch = 1/12 * m1ch * (2*l)**2 #1.066 + m1ch*(0.272**2)
I2ch = 4/3 * m2ch * l**2 #1.475 + m2ch*(0.337**2)

gch = 9.81

subsch = {m1: m1ch, l1:l,  I1: I1ch,  F12: (-m1ch*gch)}

Cch = Cs.subs(subsch)

Dch = Ds.subs(subsch)

tmp2 = (Dch.inv()@Cch)

# tmp2.eigenvects()

wa = tmp2.eigenvects()[0][2][0]

W = Matrix.hstack(wa)

Uinv = (-Dch@W).inv()

Z = Uinv@Cch@W

from functools import partial

round3 = partial(round, ndigits=4)
# Z.applyfunc(round3)

"""## SOLVE EQUATION"""



w = symbols("\omega", real=True)
t = symbols("t", real=True)
V, S = symbols("V S", real=True)
a = symbols("a", real=True)
ll = symbols("\lambda", real=True)

L = Matrix([[cos(w*t), a*cos(w*t)+w*sin(w*t)],
            [sin(w*t), a*sin(w*t)-w*cos(w*t)]])

R = Matrix([(1+ll*(w**2 - a**2))*sym.exp(a*t)-cos(w*t),
            2*ll*w*a*sym.exp(a*t)-sin(w*t)])

SV = simplify(L.inv()@R)

"""## H - synergy"""

# ll  -- наша лямбда
# а -- показатель ляпунова
# t -- задержка

import numpy as np

SVsubs = {ll:0.0272, a:-7, t:0.06}

lin =  np.linspace(1,30,10)

ArSV = SV.subs(SVsubs)

ArS = [ArSV[0].subs({w:str(i)}) for i in lin]

ArV = [ArSV[1].subs({w:str(i)}) for i in lin]

# import matplotlib.pyplot as plt

# plt.plot(ArV,ArS)

Vv = np.linspace(0.15,0.6)

Ss = -1-(ll*a**2-1)*sym.exp(a*t)
Ss = Ss.subs(SVsubs) -a.subs(SVsubs)*Vv

# H синергия
# a:-7
# lambda: 0.0272
# tau:0.06 из статьи

# S = 0.45
# V = 0.238

# Seig = [A,H]

Seig = Matrix([0.45]) # диагональная

Veig = Matrix([0.238])  # диагональная

"""### Генерация траектории"""

U = Uinv.inv()

Snorm = U@Seig@(W.inv())

Vnorm = U@Veig@(W.inv())

# Dch[0,0]/Dch[1,1]

f = 0.5 #Hz
A = 0.01

fi_des1 =  A*sin(2*np.pi*f*t)

# Пишем контроллер
# в течение 4х секунд
# timestep 1 ms
# задержки разные
#

# переводим желаемые углы в кси
# считаем торки (эта) незавиимые с разными задержками
# возвращаем торки в суставные углы

# -lambd * ddksi + ksi = eta
# eta = eta(t-tau) + Seig(ksi_des(t) - ksi(t-tau)) - Veig*dksi(t-tau) - lambda*ddksi(t-tau)

# H синергия
# a:-7
# lambda: 0.0272
# tau:0.06 из статьи

# S = 0.45
# V = 0.238

# from collections import deque

# lH = 0.0272
# SH = 0.45
# VH = 0.238

# taums_1 = 60

# fifo_ksi_H = deque([0] * taums_1)
# fifo_dksi_H = deque([0] * taums_1)
# fifo_ddksi_H = deque([0] * taums_1)

# Eta_1 = deque([0] * taums_1)

# # fifo_queue.append()
# # fifo_queue.popleft()

# for i in range(4000):
#   # we have already fi_des1 and fi_des2 is sympy
#   # fi = W @ ksi  ==>  ksi = W.inv() @ fi
#   stt = {t:i}
#   Fi_des = Matrix([fi_des1.subs(stt)])  # зависит от t
#   Ksi_des = W.inv() @ Fi_des

#   # H
#   fifo_ksi_H.append(Ksi_des[0])

#   # берем значения угловой скорости и ускорения и записываем их в очереди
#   fifo_dksi_H.append()
#   fifo_ddksi_H.append()

#   Eta_1.append()


#   # eta = eta(t-tau) + Seig(ksi_des(t) - ksi(t-tau)) - Veig*dksi(t-tau) - lambda*ddksi(t-tau)

#   eta1ttau = Eta_1.popleft()
#   ksi1ttau = fifo_ksi_H.popleft()
#   dksi1ttau = fifo_dksi_H.popleft()
#   ddksi1ttau = fifo_ddksi_H.popleft()

#   eta_1 = eta1ttau + SH*(Ksi_des[0] -  ksi1ttau) - VH * dksi1ttau - lH * ddksi1ttau

#   eta1ttau = Eta_1.popleft()

#   # eta_2 = eta2ttau + SA*(Ksi_des[1] -  ksi2ttau) - VA * dksi2ttau - lA * ddksi2ttau

#   # Uinv = (-Dch@W).inv()
#   # U = Uinv.inv()
#   # eta = (-Dch@W).inv() @ Tjt = Uinv @ Tjt
#   # Tjt = U @ eta

#   Etas = Matrix([eta_1])
#   Tcltr = U @ Etas



